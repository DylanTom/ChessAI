#Driver File - handling user input and displaying current gameState

import pygame as g
import sys
from ChessAI import ChessEngine, SmartMoveFinder

width = height = 512
dimension = 8
squareSize = height // dimension
maxFPS = 60
images = {}
g.init()
g.display.set_caption('ChessAI')
screen = g.display.set_mode((width, height))

#want to load in images at the beginning, pygame takes a lot of resources to load images each frame
def loadImages():
    pieces = ["bR", "bN", "bB", "bQ", "bK", "bP", "wP", "wR", "wN", "wB", "wQ", "wK"]
    for piece in pieces:
        images[piece]= g.transform.scale(g.image.load("Pieces/" + piece + ".png"), (squareSize,squareSize))

def main_menu():
    while True:
        screen.fill((0,0,0))
        drawText(screen, 'main menu')

        mx, my = g.mouse.get_pos()

        button1 = g.Rect(width/2,height/2, 50, 50)
        if button1.collidepoint((mx, my)):
            if click:
                main()
        g.draw.rect(screen, (255,0,0), button1)
        click = False

        for event in g.event.get():
            if event.type == g.QUIT:
                g.quit()
                sys.exit()
            if event.type == g.KEYDOWN:
                if event.key == g.K_ESCAPE:
                    g.quit()
                    sys.exit()
            if event.type == g.MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True

        g.display.update()
        g.time.Clock().tick(60)

def main():
    clock = g.time.Clock()
    screen.fill(g.Color("white"))
    gameState = ChessEngine.GameState()
    validMoves = gameState.getValidMoves()
    moveMade = False

    loadImages()
    running = True
    selected = ()
    playerClicks = []
    animate = False
    gameOver = False
    playerWhite = False
    playerBlack = True

    while running:
        humanTurn = (gameState.whiteToMove and playerWhite) or (not gameState.whiteToMove and playerBlack)
        for e in g.event.get():
            if e.type == g.QUIT:
                running = False
            elif e.type == g.MOUSEBUTTONDOWN: #click and drag implementation
                if not gameOver and humanTurn:
                    location = g.mouse.get_pos() #keep account for extra UI elements, make sure mouse location is relative to border
                    y = location[0] // squareSize
                    x = location[1] // squareSize
                    if selected == (x, y): #checks to see if user clicks the same square - undo
                        selected = ()
                        playerClicks = []
                    else:
                        selected = (x, y)
                        playerClicks.append(selected)
                    if len(playerClicks) == 2: #make move after finalizing click
                        move = ChessEngine.Move(playerClicks[0], playerClicks[1], gameState.board)
                        print(move.getChessNotation())
                        for i in range(len(validMoves)):
                            if move == validMoves[i]:
                                gameState.makeMove(validMoves[i]) #move is generated by engine not by player
                                moveMade = True
                                animate = True
                                selected = ()
                                playerClicks = []
                        if not moveMade:
                            playerClicks = [selected]
            elif e.type == g.KEYDOWN: #need to only allow one undo per move
                if e.key == g.K_z:
                    gameState.undoMove()
                    moveMade = True
                    animate = False
                if e.key == g.K_r:
                    gameState = ChessEngine.GameState()
                    validMoves = gameState.getValidMoves()
                    selected = ()
                    playerClicks = []
                    moveMade = False
                    animate = False
        if not gameOver and not humanTurn:
            move = SmartMoveFinder.findRandomMove(validMoves)
            gameState.makeMove(move)
            moveMade = True
            animate = True

        if moveMade:
            if animate:
                animation(gameState.moveLog[-1], screen, gameState.board, clock)
            validMoves = gameState.getValidMoves()
            moveMade = False
            animate = False
        drawGameState(screen, gameState, validMoves, selected)

        if gameState.checkmate:
            gameOver = True
            if gameState.whiteToMove:
                drawText(screen, 'Black wins by checkmate!')
            else:
                drawText(screen, 'White wins by checkmate!')
        elif gameState.stalemate:
            gameOver = True
            drawText(screen, 'Stalemate!')

        clock.tick(maxFPS)
        g.display.flip()

def highlightSquares(screen, gameState, validMoves, selected):
    if selected != ():
        rank, file = selected
        if gameState.board[rank][file][0] == ('w' if gameState.whiteToMove else 'b'):
            s = g.Surface((squareSize, squareSize)) #rectangular surface
            s.set_alpha(100) #transparency
            s.fill(g.Color("light blue"))
            screen.blit(s, (file*squareSize, rank*squareSize))

            s.fill(g.Color("light green"))
            for move in validMoves:
                if move.startRank == rank and move.startFile == file:
                    screen.blit(s, (move.endFile*squareSize, move.endRank*squareSize))

def drawGameState(screen, gameState, validMoves, selected):
    drawBoard(screen)
    highlightSquares(screen, gameState, validMoves, selected)
    drawPieces(screen, gameState.board) #draw pieces on top of board

def drawBoard(screen):
    global colors
    colors = [g.Color("white"), g.Color("gray")]
    for rank in range(dimension):
        for file in range(dimension):
            color = colors[(rank + file) % 2]
            g.draw.rect(screen, color, g.Rect(file*squareSize, rank*squareSize, squareSize, squareSize))

def drawPieces(screen, board): #uses current gameState.board
    for rank in range(dimension):
        for file in range(dimension):
            piece = board[rank][file]
            if piece != "--":
                screen.blit(images[piece], g.Rect(file*squareSize, rank*squareSize, squareSize, squareSize))

def animation(move, screen, board, clock):
    global colors
    coords = []
    dR = move.endRank - move.startRank
    dF = move.endFile - move.startFile
    framesPerSquare = 6
    frameCount = (abs(dR)+abs(dF)) * framesPerSquare
    for frame in range(frameCount+1):
        rank, file = (move.startRank + dR*frame/frameCount, move.startFile + dF * frame/frameCount)
        drawBoard(screen)
        drawPieces(screen, board)
        color = colors[(move.endRank + move.endFile) %2]
        endSquare = g.Rect(move.endFile * squareSize, move.endRank * squareSize, squareSize, squareSize)
        g.draw.rect(screen, color, endSquare)
        if move.pieceCaptured != "--":
            screen.blit(images[move.pieceCaptured], endSquare)
        screen.blit(images[move.pieceMoved], g.Rect(file*squareSize, rank*squareSize, squareSize, squareSize))
        g.display.flip()
        clock.tick(60)

def drawText(screen, text):
    font = g.font.SysFont("Comic Sans", 32, True, False)
    textObject = font.render(text, 0,g.Color('Red'))
    textLocation = g.Rect(0,0,width, height).move(width/2 - textObject.get_width()/2, height/2 - textObject.get_height()/2)
    screen.blit(textObject, textLocation)


if __name__ == "__main__":
    main_menu()